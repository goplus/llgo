# LLGo Project AI Assistant Guide

This document provides essential information for AI assistants to help fix bugs and implement features in the LLGo project.

## About LLGo

LLGo is a Go compiler based on LLVM designed to better integrate Go with the C ecosystem, including Python and JavaScript. It's a subproject of the XGo project that aims to expand the boundaries of Go/XGo for game development, AI and data science, WebAssembly, and embedded development.

## Project Structure

- `cmd/llgo` - Main llgo compiler command (usage similar to `go` command)
- `cl/` - Core compiler logic that converts Go packages to LLVM IR
- `ssa/` - LLVM IR file generation using Go SSA semantics
- `internal/build/` - Build process orchestration
- `runtime/` - LLGo runtime library
- `chore/` - Development tools (llgen, llpyg, ssadump, etc.)
- `_demo/` - Example programs demonstrating C/C++ interop (`c/hello`, `c/qsort`) and Python integration (`py/callpy`, `py/numpy`)
- `_cmptest/` - Comparison tests to verify the same program gets the same output with Go and LLGo

## Development Environment

For detailed dependency requirements and installation instructions, see the [Dependencies](README.md#dependencies) and [How to install](README.md#how-to-install) sections in the README.

## Testing & Validation

The following commands and workflows are essential when fixing bugs or implementing features in the LLGo project:

### Run all tests
```bash
go test ./...
```

**Note:** Some tests may fail if optional dependencies (like Python) are not properly configured. The test suite includes comprehensive tests for:
- Compiler functionality
- SSA generation
- C interop
- Python integration (requires Python development headers)

### Write and run tests for your changes

When adding new functionality or fixing bugs, create appropriate test cases:

```bash
# Add your test to the relevant package's *_test.go file
# Then run tests for that package
go test ./path/to/package

# Or run all tests
go test ./...
```

**Important:** The `LLGO_ROOT` environment variable must be set to the repository root when running llgo commands during development.

### Update out.ll files after modifying compiler IR generation

**CRITICAL:** When you modify the compiler's IR generation logic (especially in `ssa/` or `cl/` packages), you MUST update all out.ll test files under the `cl/` directory.

#### Understanding out.ll files

The `out.ll` files under the `cl/` directory are comparison IR files that serve as reference outputs for the test suite:
- They are generated by `llgen` from the corresponding `in.go` files in the same directory
- They reflect the current compiler's LLVM IR representation of the Go source code
- They are used by tests to verify that the compiler generates correct and consistent IR output

#### Required steps after modifying IR generation logic

1. **Reinstall the tools** to apply your compiler changes:
   ```bash
   go install -v ./chore/gentests
   go install -v ./chore/llgen
   ```

2. **Regenerate out.ll files**:
   
   **For batch updates (recommended)** - Use `gentests` to regenerate all test files:
   ```bash
   gentests
   ```
   This will automatically regenerate all out.ll files in these directories:
   - `cl/_testlibc`
   - `cl/_testlibgo`
   - `cl/_testrt`
   - `cl/_testgo`
   - `cl/_testpy`
   - `cl/_testdata`
   
   **For individual test inspection** - Use `llgen` to regenerate specific test directories:
   ```bash
   llgen cl/_testgo/interface
   llgen cl/_testrt/tpmethod
   ```

3. **Verify the changes** make sense by reviewing the diff in the out.ll files

4. **Commit the updated out.ll files** along with your compiler changes

#### Why this matters

This process ensures that:
- The test suite reflects the current compiler behavior
- Changes to IR generation are properly documented and reviewed
- Future regressions can be detected by comparing against the reference output

## Code Quality

Before submitting any code updates, you must run the following formatting and validation commands:

### Format code
```bash
go fmt ./...
```

**Important:** Always run `go fmt ./...` before committing code changes. This ensures consistent code formatting across the project.

### Run static analysis
```bash
go vet ./...
```

**Note:** Currently reports some issues related to lock passing by value in `ssa/type_cvt.go` and a possible unsafe.Pointer misuse in `cl/builtin_test.go`. These are known issues.


## Common Development Tasks

### Build the entire project
```bash
go build -v ./...
```

### Build llgo command specifically
```bash
go build -o llgo ./cmd/llgo
```

### Check llgo version
```bash
llgo version
```

### Install llgo for system-wide use
```bash
./install.sh
```

### Build development tools
```bash
go install -v ./cmd/...
go install -v ./chore/...
```

## Key Modules for Understanding

- `ssa` - Generates LLVM IR using Go SSA semantics
- `cl` - Core compiler converting Go to LLVM IR
- `internal/build` - Orchestrates the compilation process

## Module Architecture

### Compilation Pipeline

```
Go Source → Go SSA → llgo SSA → LLVM IR → Executable
              ↑          ↑          ↑
        (go/ssa)      (ssa/)    (llvm bindings)
```

- **Go SSA**: `golang.org/x/tools/go/ssa` - Standard Go SSA representation
- **llgo SSA**: `ssa/` package (imported as `llssa`) - Intermediate abstraction layer before LLVM IR
- **LLVM IR**: Generated via `github.com/goplus/llvm` bindings

### Package Roles

| Package | Role |
|---------|------|
| `cl/` | Converts Go SSA → llgo SSA (calls ssa's Builder API) |
| `ssa/` | Provides llgo SSA abstraction, generates LLVM IR |
| `internal/build/` | Orchestrates the build process |

### Dependency Direction

```
cl ──→ ssa ──→ llvm
```

- `cl` imports `ssa` (uses Builder, Type, Function APIs)
- `ssa` imports `llvm` bindings (generates LLVM IR)
- `ssa` does NOT import `cl`

## Debugging

### Compiler Development Workflow

When modifying the compiler, follow this workflow to test and debug:

1. **Create a test case** in `cl/_testrt/` (or appropriate `_test*` directory):
   ```bash
   mkdir cl/_testrt/mytest
   # Create in.go with your test code
   ```

2. **Generate out.ll** using llgen:
   ```bash
   go install -v ./chore/llgen
   llgen cl/_testrt/mytest
   ```
   This reads `cl/_testrt/mytest/in.go` and generates `cl/_testrt/mytest/out.ll`.

3. **Run the test** with llgo:
   ```bash
   LLGO_ROOT=/path/to/llgo go run ./cmd/llgo run -a cl/_testrt/mytest
   ```
   The `-a` flag forces rebuild of all packages.

4. **If the program crashes**, debug using **both lldb AND the generated IR** - **DO NOT blindly guess the cause**:
   ```bash
   # First build the executable
   LLGO_ROOT=/path/to/llgo go run ./cmd/llgo build -o mytest cl/_testrt/mytest

   # Debug with lldb
   lldb ./mytest
   (lldb) run
   (lldb) bt              # backtrace when it crashes
   (lldb) frame select N  # examine specific frame
   (lldb) disassemble     # see assembly at crash point
   ```

   **Cross-reference with IR**: Open `cl/_testrt/mytest/out.ll` to understand:
   - Which LLVM IR instruction corresponds to the crash
   - The control flow and basic block structure
   - How values are computed and passed

   **Example debug workflow**:
   ```
   1. lldb shows crash at address 0x12345 in function foo
   2. Open out.ll, find "define ... @foo"
   3. Match the crash location to specific IR instructions
   4. Identify the root cause (wrong type, missing null check, etc.)
   ```

### Disable Garbage Collection
For testing purposes, you can disable GC:
```bash
LLGO_ROOT=/path/to/llgo llgo run -tags nogc .
```

## LLGO_ROOT Environment Variable

**CRITICAL:** Always set `LLGO_ROOT` to the repository root when running llgo during development:

```bash
export LLGO_ROOT=/path/to/llgo
# or
LLGO_ROOT=/path/to/llgo llgo run .
```

## Key Implementation Files

When working on specific features, refer to these files:

| Feature | Key Files |
|---------|-----------|
| Defer/Panic/Recover | `ssa/eh.go` - defer structure, setjmp/longjmp, RunDefers |
| Closure | `ssa/closure_wrap.go` - closure wrappers; `ssa/expr.go` - MakeClosure |
| Type System | `ssa/type.go`, `ssa/type_cvt.go` |
| Function Calls | `cl/call.go`, `ssa/call.go` |
| C Integration | Direct LLVM symbol linking via `go:linkname`, no special CGO runtime |

## Important Notes

1. **Testing Requirement:** All bug fixes and features MUST include tests
2. **Demo Directory:** Examples in `_demo` are prefixed with `_` to prevent standard `go` command from trying to compile them
3. **Defer in Loops:** LLGo supports `defer` in loops, allocating per iteration (see `ssa/eh.go`)
4. **C Integration:** Since llgo uses LLVM, C symbols are just normal symbols - no special CGO handling needed
5. **Python Integration:** Third-party Python libraries require separate installation of library files

