package cmptest

import (
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/goplus/llgo/chore/gogensig/config"
	"github.com/goplus/llgo/chore/gogensig/convert"
	"github.com/goplus/llgo/chore/gogensig/convert/basic"
	"github.com/goplus/llgo/chore/gogensig/unmarshal"
	cppgtypes "github.com/goplus/llgo/chore/llcppg/types"
)

func GetTempHeaderPathDir() string {
	tempHeaderDir, err := filepath.Abs("./temp")
	if err != nil {
		panic(err)
	}
	return tempHeaderDir
}

// The validateFunc is used to validate the generated file,
func RunTest(t *testing.T, pkgName string, isCpp bool, symbolEntries []config.SymbolEntry, public map[string]string, cppgConf *cppgtypes.Config, originalCode, expectedOutput string, validateFunc func(t *testing.T, pkg *convert.Package)) {
	RunTestWithCheckEqual(t, pkgName, isCpp, symbolEntries, public, cppgConf, originalCode, expectedOutput, validateFunc, CheckResult)
}

func CheckResult(t *testing.T, expected, content string) {
	if strings.TrimSpace(expected) != strings.TrimSpace(content) {
		t.Errorf("does not match expected.\nExpected:\n%s\nGot:\n%s", expected, string(content))
	}
}

func CheckPubFile(t *testing.T, pkg *convert.Package, expectedPub string) {
	bytes, err := os.ReadFile(filepath.Join(pkg.GetOutputDir(), "llcppg.pub"))
	if err != nil {
		t.Fatal("llcppg.pub not found")
	}
	CheckResult(t, expectedPub, string(bytes))
}

// RunTestWithCheckEqual initializes a test Go project with local llgo dependency
func RunTestWithCheckEqual(t *testing.T, pkgName string, isCpp bool, symbolEntries []config.SymbolEntry, public map[string]string, cppgConf *cppgtypes.Config, originalCode, expectedOutput string, validateFunc func(t *testing.T, pkg *convert.Package), checkEqual func(t *testing.T, expected, content string)) {
	t.Helper()

	tempHeaderDir := GetTempHeaderPathDir()
	err := os.MkdirAll(tempHeaderDir, 0744)
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempHeaderDir)
	tempFile := filepath.Join(tempHeaderDir, "temp.h")
	absTempFile, err := filepath.Abs(tempFile)
	if err != nil {
		t.Fatal(err)
	}
	os.WriteFile(absTempFile, []byte(originalCode), 0644)
	tempDir, err := os.MkdirTemp("", "gogensig-test")
	if err != nil {
		t.Fatal("failed to create temp dir")
	}
	defer os.RemoveAll(tempDir)

	outputDir := filepath.Join(tempDir, pkgName)
	err = os.MkdirAll(outputDir, 0744)
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(outputDir)

	// reuse in main logic
	projectRoot, err := filepath.Abs("../../../")
	if err != nil {
		t.Fatal(err)
	}
	originalWd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	defer os.Chdir(originalWd)
	os.Chdir(outputDir)

	config.RunCommand(outputDir, "go", "mod", "init", pkgName)
	config.RunCommand(outputDir, "go", "get", "github.com/goplus/llgo")
	config.RunCommand(outputDir, "go", "mod", "edit", "-replace", "github.com/goplus/llgo="+projectRoot)

	symbolpath, err := CreateAndWriteTempSymbFile(symbolEntries)
	if err != nil {
		t.Fatal(err)
	}
	cfgPath, err := CreateCppgConfFile(cppgConf)
	if err != nil {
		t.Fatal(err)
	}
	pubPath, err := CreatePubFile(public)
	if err != nil {
		t.Fatal(err)
	}

	// The result file will be generated in a directory based on the package name.
	// For example, if the package name is "typeref", the result file will be generated in a directory named "typeref".
	files, err := os.ReadDir(outputDir)
	if err != nil {
		t.Fatalf("Fail to read temp dir: %v", err)
	}

	for _, file := range files {
		log.Println("Generated file:", file.Name())
	}

	p, pkg, err := basic.ConvertProcesser(&basic.Config{
		AstConvertConfig: convert.AstConvertConfig{
			PkgName:   pkgName,
			SymbFile:  symbolpath,
			CfgFile:   cfgPath,
			OutputDir: outputDir,
			PubFile:   pubPath,
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	// Fetch the signature file
	// The signature file is generated by llcppsigfetch
	bytes, err := config.SigfetchExtract(absTempFile, false, isCpp, ".")
	if err != nil {
		t.Fatal(err)
	}

	inputdata, err := unmarshal.UnmarshalFileSet(bytes)
	if err != nil {
		t.Fatal(err)
	}

	err = p.ProcessFileSet(inputdata)
	if err != nil {
		t.Fatal(err)
	}

	// Note: The converted file path for llcppsigfetch's temp header file is temp.h,
	genFilePath := filepath.Join(outputDir, "temp.go")
	content, err := os.ReadFile(genFilePath)
	if err != nil {
		t.Fatalf("Fail to read generated file: %v", err)
	}

	checkEqual(t, expectedOutput, string(content))

	if validateFunc != nil {
		validateFunc(t, pkg)
	}
}

func CreateAndWriteTempSymbFile(entries []config.SymbolEntry) (string, error) {
	return CreateJSONFile("llcppg.symb.json", entries)
}

func CreateCppgConfFile(config *cppgtypes.Config) (string, error) {
	return CreateJSONFile("llcppg.cfg", config)
}

func CreatePubFile(public map[string]string) (string, error) {
	filePath := filepath.Join(os.TempDir(), "llcppg.pub")
	file, err := os.Create(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()
	err = config.WritePubFile(filePath, public)
	if err != nil {
		return "", err
	}
	return filePath, nil
}

func CreateJSONFile(filename string, data interface{}) (string, error) {
	filePath := filepath.Join(os.TempDir(), filename)
	file, err := os.Create(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return filePath, encoder.Encode(data)
}
