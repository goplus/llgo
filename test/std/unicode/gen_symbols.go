//go:build ignore

// Code generator for unicode symbol coverage tests.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/doc"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

type methodInfo struct {
	typeName   string
	methodName string
	pointer    bool
}

func main() {
	pkg := loadDocPackage("unicode")

	consts := collectConsts(pkg)
	vars := collectVars(pkg)
	types := collectTypes(pkg)
	funcs := collectFuncs(pkg)
	methods := collectMethods(pkg)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by go run gen_symbols.go; DO NOT EDIT.\n")
	buf.WriteString("package unicode_test\n\n")
	buf.WriteString("import \"unicode\"\n\n")

	if len(consts) > 0 {
		buf.WriteString("const (\n")
		for _, name := range consts {
			buf.WriteString(fmt.Sprintf("    _ = unicode.%s\n", name))
		}
		buf.WriteString(")\n\n")
	}

	if len(vars) > 0 {
		buf.WriteString("var (\n")
		for _, name := range vars {
			buf.WriteString(fmt.Sprintf("    _ = unicode.%s\n", name))
		}
		buf.WriteString(")\n\n")
	}

	if len(types) > 0 {
		buf.WriteString("var (\n")
		for _, name := range types {
			buf.WriteString(fmt.Sprintf("    _ unicode.%s\n", name))
		}
		buf.WriteString(")\n\n")
	}

	if len(funcs) > 0 {
		buf.WriteString("var (\n")
		for _, name := range funcs {
			buf.WriteString(fmt.Sprintf("    _ = unicode.%s\n", name))
		}
		buf.WriteString(")\n\n")
	}

	if len(methods) > 0 {
		buf.WriteString("var (\n")
		for _, m := range methods {
			if m.pointer {
				buf.WriteString(fmt.Sprintf("    _ = (*unicode.%s)(nil).%s\n", m.typeName, m.methodName))
			} else {
				buf.WriteString(fmt.Sprintf("    _ = unicode.%s{}.%s\n", m.typeName, m.methodName))
			}
		}
		buf.WriteString(")\n")
	}

	outPath := relPath("unicode_symbols_test.go")
	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

func relPath(sub string) string {
	_, file, _, ok := runtime.Caller(0)
	if !ok {
		panic("runtime.Caller failed")
	}
	base := filepath.Dir(file)
	if sub == "" {
		return base
	}
	return filepath.Join(base, sub)
}

func loadDocPackage(importPath string) *doc.Package {
	cfg := &packages.Config{Mode: packages.NeedSyntax | packages.NeedFiles | packages.NeedName}
	pkgs, err := packages.Load(cfg, importPath)
	if err != nil {
		panic(err)
	}
	if packages.PrintErrors(pkgs) > 0 || len(pkgs) == 0 {
		panic("failed to load package: " + importPath)
	}

	p := pkgs[0]
	files := make(map[string]*ast.File)
	for i, f := range p.Syntax {
		if i < len(p.GoFiles) {
			files[p.GoFiles[i]] = f
		}
	}

	return doc.New(&ast.Package{Name: p.Name, Files: files}, importPath, doc.AllDecls)
}

func collectConsts(pkg *doc.Package) []string {
	set := make(map[string]struct{})
	for _, c := range pkg.Consts {
		for _, name := range c.Names {
			if ast.IsExported(name) {
				set[name] = struct{}{}
			}
		}
	}
	return sortedKeys(set)
}

func collectVars(pkg *doc.Package) []string {
	set := make(map[string]struct{})
	for _, v := range pkg.Vars {
		for _, name := range v.Names {
			if ast.IsExported(name) {
				set[name] = struct{}{}
			}
		}
	}
	return sortedKeys(set)
}

func collectTypes(pkg *doc.Package) []string {
	set := make(map[string]struct{})
	for _, t := range pkg.Types {
		if ast.IsExported(t.Name) {
			set[t.Name] = struct{}{}
		}
	}
	return sortedKeys(set)
}

func collectFuncs(pkg *doc.Package) []string {
	set := make(map[string]struct{})
	for _, f := range pkg.Funcs {
		if ast.IsExported(f.Name) {
			set[f.Name] = struct{}{}
		}
	}
	return sortedKeys(set)
}

func collectMethods(pkg *doc.Package) []methodInfo {
	var methods []methodInfo
	for _, t := range pkg.Types {
		if !ast.IsExported(t.Name) {
			continue
		}
		for _, m := range t.Methods {
			if !ast.IsExported(m.Name) {
				continue
			}
			pointer := strings.HasPrefix(strings.TrimSpace(m.Recv), "*")
			methods = append(methods, methodInfo{typeName: t.Name, methodName: m.Name, pointer: pointer})
		}
	}
	sort.Slice(methods, func(i, j int) bool {
		if methods[i].typeName == methods[j].typeName {
			return methods[i].methodName < methods[j].methodName
		}
		return methods[i].typeName < methods[j].typeName
	})
	return methods
}

func sortedKeys(set map[string]struct{}) []string {
	keys := make([]string, 0, len(set))
	for k := range set {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}
