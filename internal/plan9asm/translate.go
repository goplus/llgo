package plan9asm

import (
	"fmt"
	"strings"
)

type LLVMType string

const (
	I64 LLVMType = "i64"
)

type FuncSig struct {
	Name string
	Args []LLVMType
	Ret  LLVMType // empty means void
}

type Options struct {
	TargetTriple string
	Sig          FuncSig

	// ABI model for name+off(FP) references.
	// For now, we assume:
	//   - arg i is at offset i*8
	//   - return slot is at offset len(args)*8
	// This matches the classic stack-based ABI style used in many small asm
	// wrappers (and is sufficient for our initial tests).
}

// Translate converts a parsed Plan 9 asm Program into LLVM IR text (`.ll`).
//
// This is intentionally a small prototype and supports only a tiny subset.
func Translate(prog *Program, opt Options) (string, error) {
	if prog == nil {
		return "", fmt.Errorf("nil program")
	}
	if opt.Sig.Name == "" {
		return "", fmt.Errorf("missing function name in signature")
	}
	if prog.Func != "" && prog.Func != opt.Sig.Name {
		// Keep the translator strict for now to avoid accidentally translating a
		// different symbol than intended.
		return "", fmt.Errorf("program TEXT symbol %q does not match signature name %q", prog.Func, opt.Sig.Name)
	}
	if opt.Sig.Ret == "" {
		return "", fmt.Errorf("prototype only supports non-void return")
	}

	var b strings.Builder
	b.WriteString("; Generated by llgo internal/plan9asm (prototype)\n")
	if opt.TargetTriple != "" {
		fmt.Fprintf(&b, "target triple = %q\n\n", opt.TargetTriple)
	}

	// Function header.
	fmt.Fprintf(&b, "define %s @%s(", opt.Sig.Ret, opt.Sig.Name)
	for i, t := range opt.Sig.Args {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(&b, "%s %%arg%d", t, i)
	}
	b.WriteString(") {\n")
	b.WriteString("entry:\n")

	// Register SSA values.
	reg := map[Reg]string{}
	retv := "" // SSA value name without leading '%'
	tmp := 0
	newTmp := func() string {
		tmp++
		return fmt.Sprintf("t%d", tmp)
	}

	valueOf := func(op Operand) (string, error) {
		switch op.Kind {
		case OpImm:
			return fmt.Sprintf("%d", op.Imm), nil
		case OpReg:
			v, ok := reg[op.Reg]
			if !ok {
				// Uninitialized register -> treat as 0 for now.
				// (Real asm would use undefined value. For a prototype, being
				// explicit makes debugging easier.)
				return "0", nil
			}
			return "%" + v, nil
		case OpFP:
			// arg offset i*8
			if op.FPOffset%8 != 0 {
				return "", fmt.Errorf("unsupported FP offset (must be multiple of 8): %s", op.String())
			}
			idx := int(op.FPOffset / 8)
			if idx < len(opt.Sig.Args) && opt.Sig.Args[idx] == I64 {
				return fmt.Sprintf("%%arg%d", idx), nil
			}
			// return slot is after args
			retOff := int64(len(opt.Sig.Args) * 8)
			if op.FPOffset == retOff {
				if retv == "" {
					// Uninitialized return slot.
					return "0", nil
				}
				return "%" + retv, nil
			}
			return "", fmt.Errorf("unsupported FP slot: %s", op.String())
		default:
			return "", fmt.Errorf("invalid operand: %v", op)
		}
	}

	setReg := func(r Reg, val string) {
		// val is an SSA value with leading '%' or an immediate constant.
		// Materialize immediates into SSA to keep later ops uniform.
		if strings.HasPrefix(val, "%") {
			reg[r] = strings.TrimPrefix(val, "%")
			return
		}
		name := newTmp()
		fmt.Fprintf(&b, "  %%%s = add i64 %s, 0\n", name, val)
		reg[r] = name
	}

	setRet := func(val string) {
		if strings.HasPrefix(val, "%") {
			retv = strings.TrimPrefix(val, "%")
			return
		}
		name := newTmp()
		fmt.Fprintf(&b, "  %%%s = add i64 %s, 0\n", name, val)
		retv = name
	}

	for _, ins := range prog.Instrs {
		switch ins.Op {
		case OpTEXT:
			continue
		case OpMOVQ:
			src, dst := ins.Args[0], ins.Args[1]
			v, err := valueOf(src)
			if err != nil {
				return "", err
			}
			switch dst.Kind {
			case OpReg:
				setReg(dst.Reg, v)
			case OpFP:
				setRet(v)
			default:
				return "", fmt.Errorf("MOVQ dst unsupported: %s", dst.String())
			}

		case OpADDQ, OpSUBQ, OpXORQ:
			src, dst := ins.Args[0], ins.Args[1]
			if dst.Kind != OpReg {
				return "", fmt.Errorf("%s dst must be register in prototype: %s", ins.Op, dst.String())
			}
			lhs, err := valueOf(dst)
			if err != nil {
				return "", err
			}
			rhs, err := valueOf(src)
			if err != nil {
				return "", err
			}
			name := newTmp()
			switch ins.Op {
			case OpADDQ:
				fmt.Fprintf(&b, "  %%%s = add i64 %s, %s\n", name, lhs, rhs)
			case OpSUBQ:
				fmt.Fprintf(&b, "  %%%s = sub i64 %s, %s\n", name, lhs, rhs)
			case OpXORQ:
				fmt.Fprintf(&b, "  %%%s = xor i64 %s, %s\n", name, lhs, rhs)
			}
			reg[dst.Reg] = name

		case OpRET:
			// Prefer explicit return slot; otherwise return AX.
			if retv != "" {
				fmt.Fprintf(&b, "  ret i64 %%%s\n", retv)
			} else if ax, ok := reg[AX]; ok {
				fmt.Fprintf(&b, "  ret i64 %%%s\n", ax)
			} else {
				b.WriteString("  ret i64 0\n")
			}
		default:
			return "", fmt.Errorf("unsupported instruction: %s", ins.Op)
		}
	}

	b.WriteString("}\n")
	return b.String(), nil
}
