package plan9asm

import (
	"fmt"
	"regexp"
	"strings"
)

type LLVMType string

const (
	Void LLVMType = "void"
	I64  LLVMType = "i64"
)

type FuncSig struct {
	Name string
	Args []LLVMType
	Ret  LLVMType // use Void for void-return
}

type Options struct {
	TargetTriple string

	// ResolveSym maps the TEXT symbol (with (SB) trimmed) into the final linker
	// symbol name to emit in LLVM IR. If nil, the symbol is used as-is.
	ResolveSym func(sym string) string

	// Sigs maps resolved symbol name -> signature.
	Sigs map[string]FuncSig

	// ABI model for name+off(FP) references.
	// For now, we assume:
	//   - arg i is at offset i*8
	//   - return slot is at offset len(args)*8
	// This is only used by the prototype arithmetic subset.
}

// Translate converts a parsed Plan 9 asm File into LLVM IR text (`.ll`).
//
// This is intentionally a prototype and supports only a small subset.
func Translate(file *File, opt Options) (string, error) {
	if file == nil {
		return "", fmt.Errorf("nil file")
	}
	if len(file.Funcs) == 0 {
		return "", fmt.Errorf("empty file")
	}

	resolve := opt.ResolveSym
	if resolve == nil {
		resolve = func(s string) string { return s }
	}

	var b strings.Builder
	b.WriteString("; Generated by llgo internal/plan9asm (prototype)\n")
	if opt.TargetTriple != "" {
		fmt.Fprintf(&b, "target triple = %q\n\n", opt.TargetTriple)
	}

	for i := range file.Funcs {
		fn := &file.Funcs[i]
		name := resolve(fn.Sym)
		sig, ok := opt.Sigs[name]
		if !ok {
			return "", fmt.Errorf("missing signature for %q", name)
		}
		if sig.Name == "" {
			sig.Name = name
		}
		if sig.Name != name {
			return "", fmt.Errorf("signature name mismatch: %q vs %q", sig.Name, name)
		}
		if sig.Ret == "" {
			return "", fmt.Errorf("missing return type for %q", name)
		}
		if err := translateFunc(&b, *fn, sig); err != nil {
			return "", fmt.Errorf("%s: %v", name, err)
		}
		b.WriteString("\n")
	}
	return b.String(), nil
}

func translateFunc(b *strings.Builder, fn Func, sig FuncSig) error {
	// Function header.
	fmt.Fprintf(b, "define %s %s(", sig.Ret, llvmGlobal(sig.Name))
	for i, t := range sig.Args {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(b, "%s %%arg%d", t, i)
	}
	b.WriteString(") {\n")
	b.WriteString("entry:\n")

	// Fast path: void marker functions (TEXT ...; RET; and optionally BYTE).
	if sig.Ret == Void {
		for _, ins := range fn.Instrs {
			switch ins.Op {
			case OpTEXT, OpRET, OpBYTE:
				// ignore
			default:
				return fmt.Errorf("unsupported opcode in void function: %s", ins.Op)
			}
		}
		b.WriteString("  ret void\n")
		b.WriteString("}\n")
		return nil
	}

	// Prototype arithmetic subset: i64 only.
	if sig.Ret != I64 {
		return fmt.Errorf("prototype only supports i64/void return, got %q", sig.Ret)
	}
	for _, t := range sig.Args {
		if t != I64 {
			return fmt.Errorf("prototype only supports i64 args, got %q", t)
		}
	}

	// Register SSA values.
	reg := map[Reg]string{}
	retv := "" // SSA value name without leading '%'
	tmp := 0
	newTmp := func() string {
		tmp++
		return fmt.Sprintf("t%d", tmp)
	}

	valueOf := func(op Operand) (string, error) {
		switch op.Kind {
		case OpImm:
			return fmt.Sprintf("%d", op.Imm), nil
		case OpReg:
			v, ok := reg[op.Reg]
			if !ok {
				// Uninitialized register -> treat as 0 for now.
				return "0", nil
			}
			return "%" + v, nil
		case OpFP:
			// arg offset i*8
			if op.FPOffset%8 != 0 {
				return "", fmt.Errorf("unsupported FP offset (must be multiple of 8): %s", op.String())
			}
			idx := int(op.FPOffset / 8)
			if idx < len(sig.Args) && sig.Args[idx] == I64 {
				return fmt.Sprintf("%%arg%d", idx), nil
			}
			// return slot is after args
			retOff := int64(len(sig.Args) * 8)
			if op.FPOffset == retOff {
				if retv == "" {
					return "0", nil
				}
				return "%" + retv, nil
			}
			return "", fmt.Errorf("unsupported FP slot: %s", op.String())
		default:
			return "", fmt.Errorf("invalid operand: %v", op)
		}
	}

	setReg := func(r Reg, val string) {
		if strings.HasPrefix(val, "%") {
			reg[r] = strings.TrimPrefix(val, "%")
			return
		}
		name := newTmp()
		fmt.Fprintf(b, "  %%%s = add i64 %s, 0\n", name, val)
		reg[r] = name
	}

	setRet := func(val string) {
		if strings.HasPrefix(val, "%") {
			retv = strings.TrimPrefix(val, "%")
			return
		}
		name := newTmp()
		fmt.Fprintf(b, "  %%%s = add i64 %s, 0\n", name, val)
		retv = name
	}

	for _, ins := range fn.Instrs {
		switch ins.Op {
		case OpTEXT:
			continue
		case OpMOVQ:
			src, dst := ins.Args[0], ins.Args[1]
			v, err := valueOf(src)
			if err != nil {
				return err
			}
			switch dst.Kind {
			case OpReg:
				setReg(dst.Reg, v)
			case OpFP:
				setRet(v)
			default:
				return fmt.Errorf("MOVQ dst unsupported: %s", dst.String())
			}

		case OpADDQ, OpSUBQ, OpXORQ:
			src, dst := ins.Args[0], ins.Args[1]
			if dst.Kind != OpReg {
				return fmt.Errorf("%s dst must be register in prototype: %s", ins.Op, dst.String())
			}
			lhs, err := valueOf(dst)
			if err != nil {
				return err
			}
			rhs, err := valueOf(src)
			if err != nil {
				return err
			}
			name := newTmp()
			switch ins.Op {
			case OpADDQ:
				fmt.Fprintf(b, "  %%%s = add i64 %s, %s\n", name, lhs, rhs)
			case OpSUBQ:
				fmt.Fprintf(b, "  %%%s = sub i64 %s, %s\n", name, lhs, rhs)
			case OpXORQ:
				fmt.Fprintf(b, "  %%%s = xor i64 %s, %s\n", name, lhs, rhs)
			}
			reg[dst.Reg] = name

		case OpRET:
			if retv != "" {
				fmt.Fprintf(b, "  ret i64 %%%s\n", retv)
			} else if ax, ok := reg[AX]; ok {
				fmt.Fprintf(b, "  ret i64 %%%s\n", ax)
			} else {
				b.WriteString("  ret i64 0\n")
			}

		case OpBYTE:
			// Ignore raw machine bytes for now (prototype).
			continue
		default:
			return fmt.Errorf("unsupported instruction: %s", ins.Op)
		}
	}

	b.WriteString("}\n")
	return nil
}

var llvmIdentRe = regexp.MustCompile(`^[A-Za-z_][A-Za-z0-9_]*$`)

func llvmGlobal(name string) string {
	// LLVM requires quoting if name contains special characters (like / or .).
	if llvmIdentRe.MatchString(name) {
		return "@" + name
	}
	return "@\"" + strings.ReplaceAll(name, "\"", "\\\"") + "\""
}

