# Revised Analysis: Reusing Go Standard Library Syscall Code in LLGo

## Key Insight

After deep analysis of the call chain, the proposal **IS feasible** for ALL platforms, with the right compiler intrinsics.

## Call Chain Analysis

### Go's Current Call Chain (Darwin/OpenBSD)

```
Layer 1: syscall package (zsyscall_darwin_arm64.go)
=========================================================
func Lchown(path string, uid int, gid int) (err error) {
    _, _, e1 := syscall(abi.FuncPCABI0(libc_lchown_trampoline),
                        uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
    ...
}
func libc_lchown_trampoline()  // empty declaration

Layer 2: runtime syscall wrapper (sys_darwin.go)
=========================================================
func syscall_syscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {
    args := struct{ fn, a1, a2, a3, r1, r2, err uintptr }{fn, a1, a2, a3, ...}
    entersyscall()
    libcCall(unsafe.Pointer(abi.FuncPCABI0(syscall)), unsafe.Pointer(&args))
    exitsyscall()
    return args.r1, args.r2, args.err
}

Layer 3: libcCall (sys_libc.go)
=========================================================
func libcCall(fn, arg unsafe.Pointer) int32 {
    // ... traceback setup
    res := asmcgocall(fn, arg)  // Switch to system stack, call fn(arg)
    return res
}

Layer 4: asmcgocall (asm_arm64.s)
=========================================================
TEXT ·asmcgocall(SB)
    MOVD fn+0(FP), R1    // R1 = runtime·syscall
    MOVD arg+8(FP), R0   // R0 = &args (struct pointer)
    // ... switch to g0 stack
    BL (R1)              // call runtime·syscall(&args)

Layer 5: runtime·syscall (sys_darwin_arm64.s)
=========================================================
TEXT runtime·syscall(SB)
    MOVD 0(R0), R12      // R12 = args.fn = address of lchown
    MOVD 8(R0), R0       // a1 (clobbers struct pointer!)
    MOVD 16(R0), R1      // a2  ← BUG: R0 was already clobbered!
                         // Actually reads from saved copy, see full code
    MOVD 24(R0), R2      // a3
    BL (R12)             // call lchown(a1, a2, a3)
    // ... store results back

Layer 6: Final C call
=========================================================
lchown(path, uid, gid)
```

### What LLGo Can Do

**LLGo doesn't need Layers 2-5!** We can directly generate:

```
LLGo's Call Chain:
==================
Layer 1: syscall package (SAME Go code, no modification)
=========================================================
func Lchown(path string, uid int, gid int) (err error) {
    _, _, e1 := syscall(abi.FuncPCABI0(libc_lchown_trampoline),
                        uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
    ...
}

Compiler recognizes:
  - abi.FuncPCABI0(libc_lchown_trampoline) → returns @lchown address
  - syscall(fn, a1, a2, a3) → generates: call fn(a1, a2, a3) + errno handling

Layer 2: Direct C call (generated by LLGo)
=========================================================
%result = call i32 @lchown(ptr %path, i32 %uid, i32 %gid)
%is_error = icmp eq i32 %result, -1
br i1 %is_error, label %get_errno, label %success
get_errno:
  %errno_ptr = call ptr @__error()
  %errno = load i32, ptr %errno_ptr
  ...
```

---

## Complete Platform Analysis

### All Go-Supported Platforms with zsyscall Files

| Platform | File(s) | Pattern | Intrinsic Needed |
|----------|---------|---------|------------------|
| Darwin (macOS/iOS) | `zsyscall_darwin_{amd64,arm64}.go` | libc trampoline | `llgo.funcPCABI0` + `llgo.syscall` |
| OpenBSD | `zsyscall_openbsd_{386,amd64,arm,arm64,mips64,ppc64,riscv64}.go` | libc trampoline | Same as Darwin |
| Linux | `zsyscall_linux_{386,amd64,arm,arm64,loong64,mips*,ppc64*,riscv64,s390x}.go` | Raw syscall number | `llgo.Syscall` (with mapping) |
| FreeBSD | `zsyscall_freebsd_{386,amd64,arm,arm64,riscv64}.go` | Raw syscall number | Same as Linux |
| NetBSD | `zsyscall_netbsd_{386,amd64,arm,arm64}.go` | Raw syscall number | Same as Linux |
| DragonFly | `zsyscall_dragonfly_amd64.go` | Raw syscall number | Same as Linux |
| Solaris/Illumos | `zsyscall_solaris_amd64.go` | sysvicall6 | `llgo.sysvicall6` |
| AIX | `zsyscall_aix_ppc64.go` | syscall6 (libc pointer) | `llgo.syscall6` (indirect) |
| Windows | `zsyscall_windows.go` | LazyDLL/LazyProc | `llgo.SyscallN` + runtime |
| WASI | `fs_wasip1.go` | wasmimport | `//go:wasmimport` directive |
| JS/WASM | `syscall_js.go` | JS interop | `syscall/js` package |
| Plan 9 | `zsyscall_plan9_{386,amd64,arm}.go` | Syscall with ErrorString | `llgo.Syscall` (Plan9) |

---

## What Must Be Implemented as Compiler Intrinsics

### 1. `abi.FuncPCABI0` (or `llgo.funcPCABI0`)

**Detection:**
```go
func FuncPCABI0(f interface{}) uintptr
```

**Behavior:**
- If `f` is `libc_XXX_trampoline` (empty function, name pattern) → return `@XXX` symbol address
- If `f` is regular function → return function pointer

**LLVM IR:**
```llvm
; For abi.FuncPCABI0(libc_lchown_trampoline)
declare void @lchown(...)  ; external C function
%addr = ptrtoint ptr @lchown to i64
```

### 2. Syscall Intrinsics by Platform Category

#### Category A: libc Trampoline (Darwin, OpenBSD)

```go
// Uses function pointer from abi.FuncPCABI0
//go:linkname syscall llgo.syscall
func syscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)

//go:linkname syscall6 llgo.syscall6
func syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)

//go:linkname syscall6X llgo.syscall6X
func syscall6X(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)

//go:linkname syscallPtr llgo.syscallPtr
func syscallPtr(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)

//go:linkname rawSyscall llgo.rawSyscall
func rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)

//go:linkname rawSyscall6 llgo.rawSyscall6
func rawSyscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
```

**LLVM IR:**
```llvm
define {i64, i64, i64} @"llgo.syscall"(i64 %fn, i64 %a1, i64 %a2, i64 %a3) {
    %fn_ptr = inttoptr i64 %fn to ptr
    %result = call i64 %fn_ptr(i64 %a1, i64 %a2, i64 %a3)
    %is_err = icmp eq i64 %result, -1
    br i1 %is_err, label %error, label %success
error:
    %errno_ptr = call ptr @__error()  ; Darwin
    %errno = load i32, ptr %errno_ptr
    %errno_ext = zext i32 %errno to i64
    %ret_err = insertvalue {i64, i64, i64} {i64 -1, i64 0, i64 undef}, i64 %errno_ext, 2
    ret {i64, i64, i64} %ret_err
success:
    %ret_ok = insertvalue {i64, i64, i64} {i64 undef, i64 0, i64 0}, i64 %result, 0
    ret {i64, i64, i64} %ret_ok
}
```

#### Category B: Raw Syscall Number (Linux, FreeBSD, NetBSD, DragonFly)

```go
// Uses syscall number, maps to libc function
//go:linkname Syscall llgo.Syscall
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)

//go:linkname Syscall6 llgo.Syscall6
func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)

//go:linkname RawSyscall llgo.RawSyscall
func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)

//go:linkname RawSyscall6 llgo.RawSyscall6
func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
```

**Implementation options:**
1. **Map to libc** (recommended): Look up libc function by syscall number
2. **Inline syscall**: Generate platform-specific syscall instruction

#### Category C: SYSV-style libc (Solaris)

```go
// Uses libc pointer variable
//go:linkname sysvicall6 llgo.sysvicall6
func sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)

//go:linkname rawSysvicall6 llgo.rawSysvicall6
func rawSysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
```

**Pattern:**
```go
// In zsyscall_solaris_amd64.go:
r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&libc_accept4)), 4, ...)
```

The first argument is a pointer to `libcFunc` variable. LLGo should:
1. Dereference to get function pointer
2. Call with the given arguments

#### Category D: Windows DLL calls

```go
//go:linkname Syscall llgo.SyscallWindows
func Syscall(trap, nargs, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)

//go:linkname Syscall6 llgo.Syscall6Windows
func Syscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)

//go:linkname SyscallN llgo.SyscallNWindows
func SyscallN(trap uintptr, args ...uintptr) (r1, r2 uintptr, err Errno)
```

**Additional runtime support needed:**
- `LazyDLL.Load()` → calls `LoadLibraryW`
- `LazyProc.Find()` → calls `GetProcAddress`
- Error handling via `GetLastError()`

#### Category E: Plan 9

```go
// Returns ErrorString instead of Errno
//go:linkname Syscall llgo.SyscallPlan9
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err ErrorString)

//go:linkname Syscall6 llgo.Syscall6Plan9
func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err ErrorString)
```

**Error handling:** Call `errstr()` on failure to get error string.

#### Category F: WASI

```go
//go:wasmimport wasi_snapshot_preview1 fd_read
func fd_read(fd int32, iovs *iovec, iovsLen size, nread *size) Errno
```

**Compiler support:** Generate WASM import declarations directly.

---

## Runtime Trampolines Analysis

The `runtime` package on Darwin/OpenBSD uses its own set of trampolines (separate from syscall package):

### Purpose of Runtime Trampolines

| Trampoline | Purpose | C Function |
|------------|---------|------------|
| `write_trampoline` | Debug output, panic messages | `write()` |
| `read_trampoline` | Reading from fd | `read()` |
| `open_trampoline` | Opening files | `open()` |
| `close_trampoline` | Closing fd | `close()` |
| `mmap_trampoline` | Memory allocation | `mmap()` |
| `munmap_trampoline` | Memory deallocation | `munmap()` |
| `madvise_trampoline` | Memory hints | `madvise()` |
| `pthread_create_trampoline` | Thread creation | `pthread_create()` |
| `pthread_mutex_*_trampoline` | Mutex operations | `pthread_mutex_*()` |
| `pthread_cond_*_trampoline` | Condition variables | `pthread_cond_*()` |
| `pthread_attr_*_trampoline` | Thread attributes | `pthread_attr_*()` |
| `nanotime_trampoline` | High-resolution time | `mach_absolute_time()` |
| `usleep_trampoline` | Sleep | `usleep()` |
| `raise_trampoline` | Signal raising | `raise()` |
| `pthread_kill_trampoline` | Signal to thread | `pthread_kill()` |
| `sigaction_trampoline` | Signal handling | `sigaction()` |
| `sigprocmask_trampoline` | Signal mask | `sigprocmask()` |
| `kevent_trampoline` | kqueue events | `kevent()` |
| `kqueue_trampoline` | Create kqueue | `kqueue()` |

### LLGo Handling

**These are NOT a blocker for syscall package reuse** because:

1. LLGo has its own runtime implementation
2. Runtime calls can be implemented directly as C function calls
3. No need to intercept Go's runtime trampolines

For LLGo's runtime, implement these as direct C calls:
```go
// In LLGo runtime (runtime/c package)
//go:linkname write C.write
func write(fd int32, p unsafe.Pointer, n int32) int32
```

---

## Intrinsic Variant Summary

Based on the analysis, LLGo needs these intrinsic variants:

| Intrinsic | Platforms | First Arg | Error Handling |
|-----------|-----------|-----------|----------------|
| `llgo.syscall` | Darwin, OpenBSD | Function pointer | errno via `__error()` |
| `llgo.Syscall` | Linux, FreeBSD, NetBSD, DragonFly | Syscall number | errno via `__errno_location()` |
| `llgo.sysvicall6` | Solaris, Illumos | `*libcFunc` | errno via `___errno()` |
| `llgo.syscall6` | AIX | `*libcFunc` | errno via `_Errno()` |
| `llgo.SyscallWindows` | Windows | Proc address | `GetLastError()` |
| `llgo.SyscallPlan9` | Plan 9 | Syscall number | `errstr()` → ErrorString |

### Can We Unify?

**Yes, partially!** The core intrinsics can be:

1. **`llgo.syscallFnPtr(fn, ...)`** - For all platforms using function pointer (Darwin, OpenBSD, Solaris, AIX)
2. **`llgo.syscallNum(trap, ...)`** - For platforms using syscall number (Linux, FreeBSD, NetBSD, DragonFly)
3. **`llgo.SyscallWindows(proc, ...)`** - Windows-specific (needs GetLastError)
4. **`llgo.SyscallPlan9(trap, ...)`** - Plan 9-specific (needs ErrorString return)

The platform-specific parts are:
- Errno retrieval function name
- Return type (Errno vs ErrorString)
- Error check condition (-1 vs platform-specific)

---

## entersyscall/exitsyscall Handling

These runtime functions are called in Go's wrapper but **LLGo bypasses them entirely**:

```go
// Go's runtime wrapper (we don't use this)
func syscall_syscall(...) {
    entersyscall()    // LLGo: use llgo.skip
    libcCall(...)
    exitsyscall()     // LLGo: use llgo.skip
}
```

**LLGo solution:** Use `llgo.skip` directive to make these no-ops:
```go
//go:linkname entersyscall llgo.skip
func entersyscall()

//go:linkname exitsyscall llgo.skip
func exitsyscall()
```

Since LLGo provides its own `syscall.syscall` intrinsic, the Go runtime wrapper is never called, and these functions are not needed.

---

## Summary: What Can Be Reused Without Modification

| Package/File | Platform | Can Reuse? | Notes |
|--------------|----------|------------|-------|
| `syscall/zsyscall_darwin_*.go` | Darwin | ✅ 100% | With funcPCABI0 + syscall intrinsics |
| `syscall/zsyscall_openbsd_*.go` | OpenBSD | ✅ 100% | Same as Darwin |
| `syscall/zsyscall_linux_*.go` | Linux | ✅ 100% | With Syscall number mapping |
| `syscall/zsyscall_freebsd_*.go` | FreeBSD | ✅ 100% | Same as Linux |
| `syscall/zsyscall_netbsd_*.go` | NetBSD | ✅ 100% | Same as Linux |
| `syscall/zsyscall_dragonfly_*.go` | DragonFly | ✅ 100% | Same as Linux |
| `syscall/zsyscall_solaris_*.go` | Solaris | ✅ 100% | With sysvicall6 intrinsic |
| `syscall/zsyscall_aix_*.go` | AIX | ✅ 100% | With syscall6 intrinsic |
| `syscall/zsyscall_windows.go` | Windows | ✅ 100% | With LazyDLL runtime + SyscallN |
| `syscall/fs_wasip1.go` | WASI | ✅ 100% | With wasmimport support |
| `syscall/syscall_js.go` | JS/WASM | ✅ 100% | With syscall/js package |
| `syscall/zsyscall_plan9_*.go` | Plan 9 | ✅ 100% | With ErrorString handling |
| `syscall/zsyscall_*.s` | All | ❌ Skip | Assembly not needed |
| `runtime/sys_darwin.go` | Darwin | ❌ 0% | LLGo has own runtime |
| `runtime/sys_*.s` | All | ❌ Skip | Assembly not needed |

---

## Implementation Priority

### Phase 1: Darwin (Proof of Concept)
1. Implement `llgo.funcPCABI0` intrinsic
2. Implement `llgo.syscall` family intrinsics (lowercase)
3. Skip all `.s` files in syscall package
4. Test with `zsyscall_darwin_arm64.go`

### Phase 2: Linux
1. Create syscall number → libc function mapping
2. Implement `llgo.Syscall` (capital S) for numeric syscalls
3. Test with `zsyscall_linux_amd64.go`

### Phase 3: Other Unix-like
1. FreeBSD, NetBSD, DragonFly - reuse Linux intrinsics
2. Solaris - implement `llgo.sysvicall6`
3. AIX - extend syscall6 for libcFunc pointer

### Phase 4: Windows
1. Implement LazyDLL/LazyProc in LLGo runtime
2. Implement Syscall/Syscall6/.../SyscallN
3. Test with `zsyscall_windows.go`

### Phase 5: Special Platforms
1. WASI - Support `//go:wasmimport` directive
2. Plan 9 - Implement ErrorString handling
3. JS/WASM - Implement syscall/js package

---

## Errno Location Functions by Platform

| Platform | Function | Notes |
|----------|----------|-------|
| Darwin (macOS) | `__error()` | Returns `*int` |
| Linux (glibc) | `__errno_location()` | Returns `*int` |
| Linux (musl) | `__errno_location()` | Same as glibc |
| FreeBSD | `__error()` | Same as Darwin |
| NetBSD | `__errno()` | Returns `*int` |
| OpenBSD | `__errno()` | Returns `*int` |
| DragonFly | `__error()` | Same as Darwin |
| Solaris | `___errno()` | Returns `*int` |
| AIX | `_Errno()` | Returns `*int` |
| Windows | `GetLastError()` | Returns error code directly |
| Plan 9 | `errstr()` | Returns error string |
